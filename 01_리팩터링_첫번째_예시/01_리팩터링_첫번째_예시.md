# 01 리팩터링: 첫 번째 예시

<br>

- 1.1 [자\_시작해보자!](자_시작해보자!)

- 1.2 [예시*프로그램을*본\_소감](예시_프로그램을_본_소감)

- 1.3 [리팩터링의*첫*단계](리팩터링의_첫_단계)

- 1.4 [statement()*함수*쪼개기](<statement()_함수_쪼개기>)

<br>

---

<br>

<br>

### :star: 1.1 자\_시작해보자!

리팩터링을 실제로 해보는 예를 책 앞쪽에 배치했습니다. 리팩터링 과정을 따라오면서 리팩터링을 어떻게 수행하는지 감을 잡아봅시다.

<br>

<br>

<br>

### :star: 1.2 예시*프로그램을*본\_소감

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가합니다.

<br>

사용자의 입맛에 맞게 수정할 부분을 발견해봅시다. 오래 사용할 프로그램이라면 `중복 코드`는 골칫거리가 됩니다. 잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없습니다. 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 합니다.

<br>

<br>

<br>

### :star: 1.3 리팩터링의*첫*단계

> 리팩터링하기 전에 제대로 된 테스트부터 마련합니다. 테스트는 반드시 자가진단하도록 만듭니다.

<br>

리팩터링의 첫 단계는 항상 똑같습니다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 `테스트 코드`들부터 마련해야 합니다. 리팩터링에서의 `테스트`의 역할은 굉장히 중요합니다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든 실수할 수 있습니다. 프로그램이 클수록 수정 과정에서 에상치 못한 문제가 발생할 가능성이 큽니다.

원하는 내용을 소스코드와 테스트 코드 양쪽에 적어두면 두번 다 똑같이 실수하지 않는 한 버그 검출기에 반드시 걸립니다. 이와 같은 중복 검사로 실수 가능성을 크게 줄일 수 있습니다. 테스트를 작성하는 데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어 전체 작업 시간은 오히려 단축됩니다.

<br>

<br>

<br>

### :star: 1.4 statement()*함수*쪼개기

먼저 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인합니다. `함수 안에서 값이 바뀌는 변수는 조심해서 다뤄야합니다.`

<br>

아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직합니다. `조금씩 변경하고 매번 테스트하는 것이 리팩터링 절차의 핵심입니다.` 한번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어납니다.

<br>

> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행합니다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있습니다.

<br>

하나의 리팩터링을 문제없이 끝낼 때마다 커밋합니다. 그래야 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 있습니다. 어느 정도 의미 있는 단위로 뭉쳐지면 공유저장소로 푸시합니다.

<br>

변수의 이름을 더 명확하게 바꿔봅시다. 필자는 함수의 반환 값에는 항상 `result`라는 이름을 씁니다. 그러면 그 변수의 역할을 쉽게 알 수 있기 때문입니다. 인수인 `perf`는 `aPerformance`라고 바꿔주는 등 명확하게 바꿔줍니다. 필자는 매개변수 이름에 접두어로 `타입이름`을 적는데, 매개변수의 역할이 뚜렷하지 않을 때는 `부정 관사(a/an)`을 붙입니다.

<br>

> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있습니다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자입니다.

<br>

좋은 코드라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다란 역할을 합니다. 그러니 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 맙시다. '찾아 바꾸기' 기능을 제공하는 도구를 사용하면 어렵지 않습니다.

긴 함수를 쪼갤 때는 필요 없는 임시 변수를 최대한 제거합니다. 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해지기 때문입니다. 이를 해결해주는 리팩터링으로는 `임시 변수를 질의 함수로 바꾸기`가 있습니다.
