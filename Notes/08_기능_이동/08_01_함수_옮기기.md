# :star: 8-1 함수 옮기기

<br>

<img src="../../Images/08_01_image.jpeg" width="300px">

- 1판에서의 이름: 메서드 이동

<br>

```js
class Account {
  get overdraftCharge() {...}

```

<br>

```js
class AccountType {
  get overdraftCharge() {...}
```

<br>

### 배경

좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘 되어 있냐를 뜻하는 모듈성(modularity)입니다. 모듈성이란 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력입니다. 모듈성을 높이려면 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 합니다. 하지만 프로그램을 얼마나 잘 이해했느냐에 따라 구체적인 방법이 달라질 수 있습니다. 보통은 이해가 높아질수록 소프트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 됩니다. 그래서 높아진 이해를 반영하려면 요소들을 이리저리 옮겨야 할 수 있습니다.

<br>

모든 함수는 어떤 컨텍스트 안에 존재합니다. 전역 함수도 있지만 대부분은 특정 모듈에 속합니다. 객체 지향 프로그래밍의 핵심 모듈화 컨텍스트는 클래스입니다. 또한 함수를 다른 함수에 중첩시켜도 또 다른 공동 컨텍스트를 만들게 됩니다. 프로그래밍 언어들은 저마다의 모듈화 수단을 제공하며, 각각의 수단이 함수가 살아 숨 쉬는 컨텍스트를 만들어줍니다.

<br>

어떤 함수가 자신이 속한 모듈 A의 요소들보다 다른 모듈 B의 요소들을 더 많이 참조한다면 모듈 B로 옮겨줘야 마땅합니다. 이렇게 하면 캡슐화가 좋아져서, 이 소프트웨어의 나머지 부분은 모듈 B의 세부사항에 덜 의존하게 됩니다.

<br>

이와 비슷하게, 호출자들의 현재 위치(호출자가 속한 모듈)나 다음 업데이트 때 바뀌리라 예상되는 위치에 따라서도 함수를 옮겨야 할 수 있습니다. 예컨대 다른 함수 안에서 도우미 역할로 정의된 함수 중 독립적으로도 고유한 가치가 있는 것은 접근하기 더 쉬운 장소로 옮기는 게 낫습니다. 또한 다른 클래스로 옮겨두면 사용하기 더 편한 메서드도 있습니다.

<br>

함수를 옮길지 말지를 정하기란 쉽지 않습니다. 그럴 땐 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보면 도움이 됩니다. 대상 함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 또 무엇이 있는지, 대상 함수가 사용하는 데이터는 무엇인지를 살펴봐야 합니다. 서로 관련된 여러 함수들을 묶을 새로운 컨텍스트가 필요해질 때도 많은데, 이럴 때는 여러 함수를 [`클래스로 묶기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_09_여러_함수를_클래스로_묶기.md)나 [`클래스 추출하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/07_캡슐화/07_05_클래스_추출하기.md)로 해결할 수 있습니다. 함수의 최적 장소를 정하기가 어려울 수 있으나, 선택이 어려울수록 큰 문제가 아닌 경우가 많습니다. 경험상 함수들을 한 컨텍스트에 두고 작업해보는 것도 괜찮습니다. 그곳이 얼마나 적합한지는 차차 깨달아갈 것임을 알고 있고, 잘 맞지 않다고 판단되면 위치는 언제든 옮길 수 있으니 말입니다.

<br>

### 절차

1️⃣ 선택한 함수가 현재 컨텍스트에서 사용 주인 모든 프로그램 요소를 살펴본다. 이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다.

- 호출되는 함수 중 함께 옮길 게 있다면 대체로 그 함수를 먼저 옮기는 게 낫습니다. 얽혀 이쓴ㄴ 함수가 여러 개라면 다른 곳에 미치는 영향이 적은 함수부터 옮기도록 합시다.
- 하위 함수들의 호출자가 고수준 함수 하나뿐이면 먼저 하위 함수들을 고수준 함수에 인라인한 다음, 고수준 함수를 옮기고, 옮긴 위치에서 갲별 함수들로 다시 추출합시다.

<br>

2️⃣ 선택한 함수가 다형 메서드인지 확인한다.

- 객체 지향 언어에서는 같은 메서드가 슈퍼클래스나 서브클래스에도 선언되어 있는지까지 고려해야 합니다.

<br>

3️⃣ 선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 만든 새로운 함수를 타깃 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.

- 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 해당 요소들을 매개변수로 넘기거나 소스 컨텍스트 자체를 참조로 넘겨줍니다.
- 함수를 옮기게 되면 새로운 컨텍스트에 어울리는 새로운 이름으로 바꿔줘야 할 경우가 많습니다. 필요하면 바꿔줍니다.

<br>

4️⃣ 정적 분석을 수행한다.

<br>

5️⃣ 소스 컨텍스트에서 타깃 함수를 참조할 방법을 찾아 반영한다.

<br>

6️⃣ 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.

<br>

7️⃣ 테스트한다.

<br>

8️⃣ 소스 [`함수를 인라인`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_02_함수_인라인하기.md)할지 고민해본다.

- 소스 함수는 언제까지라도 위임 함수로 남겨둘 수 있습니다. 하지만 소스 함수를 호출하는 곳에서 타깃 함수를 직접 호출하는 데 무리가 없다면 중간 단계(소스 함수)는 제거하는 편이 낫습니다.

<br>

### 예시: 중첩 함수를 최상위로 옮기기

GPS 추적 기록의 총 거리를 계산하는 함수로 시작해봅시다.

<br>

```js
function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calcultateDistance();
  const pace = totalTime / 60 / totalDistance;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };
}

function calcultateDistance() { // 총 거리 계산
  let result = 0;
  for (let i = 1; i < points.length; i++){
    result += distance(points[i-1],points[i]);
  }
  return result;
}

function distance(p1, p2) { ... } // 두 지점의 거리 계산
function radians(degress) { ... } // 라디안 값으로 변환
function calculateTime() { ... } // 총 시간 계산
```

<br>

이 함수에서 중첩 함수인 `calculateDistance()`를 최상위로 옮겨서 추적 거리를 다른 정보와는 독립적으로 계산하고 싶습니다.

<br>

3️⃣ 가장 먼저 할 일은 이 함수를 최상위로 복사하는 것입니다.

<br>

```js
function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calcultateDistance();
  const pace = totalTime / 60 / totalDistance;
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  };
}

function calcultateDistance() {
  let result = 0;
  for (let i = 1; i < points.length; i++){
    result += distance(points[i-1],points[i]);
  }
  return result;
}

function distance(p1, p2) { ... }
function radians(degress) { ... }
function calculateTime() { ... }

function top_calculateDistance() { // 최상위로 복사하면서 새로운 (임시) 이름을 지어줌
  let result = 0;
  for (let i = 1; i < points.length; i++) {
    result += distance(points[i-1], points[i]);
  }
  return result;
}
```

<br>

이처럼 함수를 복사할 때 이름을 달리해주면 코드에서나 머릿속에서나 소스 함수와 타깃 함수가 쉽게 구별됩니다. 지금은 가장 적합한 이름을 고민할 단계가 아니므로 임시로 지어주면 됩니다.

<br>

이 프로그램은 지금 상태로도 동작은 하지만 제 정적 분석기는 불만을 토로합니다. 새 함수가 정의되지 않은 심벌(distance와 points)을 사용하기 때문입니다. points는 매개변수로 넘기면 자연스러울 것입니다.

<br>

```js
function top_calculateDistance(points) {
  let result = 0;
  for (let i = 1; i < points.length; i++) {
    result += distance(points[i - 1], points[i]);
  }
  return result;
}
```

<br>

1️⃣ `distance()` 함수도 똑같이 처리할 수 있지만 `calculateDistance()`와 함께 옮기는 게 합리적으로 보입니다. 다음은 `distance()` 자신과 `distance()`가 의존하는 코드입니다.

<br>

<br>

<br>

## 다음 챕터

- [8.2 - 필드 옮기기](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/08_기능_이동/08_02_필드_옮기기.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/08_기능_이동/08_00_기능_이동.md)
