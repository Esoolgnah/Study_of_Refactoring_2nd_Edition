# :star: 3-10 데이터 뭉치

<br>

데이터 항목들은 어린아이 같이 서로 어울려 노는 걸 좋아합니다. 그래서 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있습니다. 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되기도 합니다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅합니다.

<br>

가장 먼저 필드 형태의 데이터 뭉치를 찾아서 [`클래스 추출하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/07_캡슐화/07_05_클래스_추출하기.md)로 하나의 객체로 묶습니다. 다음은 메서드 시그니처에 있는 데이터 뭉치 차례입니다. 먼저 [`매개변수 객체 만들기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_08_매개변수_객체_만들기.md)나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여봅니다. 그 즉시 메서드 호출 코드가 간결해질 것입니다. 데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 걱정할 필요 없습니다. 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문입니다.

<br>

데이터 뭉치인지 판별하려면 값 하나를 삭제해봅시다. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻입니다.

<br>

방금 설명에서 간단한 레코드 구조가 아닌 '클래스'로 만들기를 권했음을 눈치채셨나요? 클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생기기 때문입니다. 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋은 동작은 없는지 살펴봅시다. 이러한 연계 과정은 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어지기도 합니다. 데이터 뭉치가 생산성에 기여하는 정식 멤버로 등극하는 순간입니다.

<br>

<br>

## 다음 챕터

- [3.11 - 기본형 집착](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_11_기본형_집착.md)

<br>

## 이전 챕터

- [3.9 - 기능 편애](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_09_기능_편애.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_00_코드에서_나는_악취.md)
