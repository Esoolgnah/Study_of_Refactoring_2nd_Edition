# :star: 3-6 가변 데이터

<br>

데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있습니다. 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동합니다. 특히 이 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵습니다. 이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 ㅇ낳고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있습니다.

<br>

하지만 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머가 더 많습니다. 그렇다고 해서 불변성이 주는 장점을 포기할 필요는 없습니다. 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있습니다.

<br>

가령 [`변수 캡슐화하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_06_변수_캡슐화하기.md)를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽습니다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 `변수 쪼개기`를 이용하여 용도별로 독립 변수에 저장하여 값 갱신이 문제를 일으킬 여지를 없앱니다. 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋습니다. 그러기 위해 `문장 슬라이드하기`와 [`함수 추출하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_01_함수_추출하기.md)를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리합니다. API를 만들 때는 질의 함수와 변경 함수 분리하기를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 합니다. 가능한 한 `세터 제거하기`도 적용하는 것이 좋습니다. 간혹 세터(setter)를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있습니다.

<br>

값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약합니다. 혼동과 버그와 야근을 부를 뿐만 아니라, 쓸데없는 코드이기도 합니다. 이럴 때는 `파생 변수를 질의 함수로 바꾸기`에 식초 농축액을 섞어서 코드 전체에 골고루 뿌려줍니다.

<br>

변수의 유효범위가 단 몇 줄뿐이라면 가변 데이터라 해도 문제를 일으킬 일이 별로 없습니다. 하지만 나중에 유효범위가 넓어질 수 있고, 그러면 위험도 덩달아 커집니다. 따라서 `여러 함수를 클래스로 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해서 변수를 갱신하는 코드들의 유효범위를 (클래스나 변환(transform)으로) 제한합니다. 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 `참조를 값으로 바꾸기`를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫습니다.

<br>

<br>

## 다음 챕터

- [3.7 - 뒤엉킨 변경](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_07_뒤엉킨_변경.md)

<br>

## 이전 챕터

- [3.5 - 전역 데이터](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_05_전역_데이터.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_00_코드에서_나는_악취.md)
