# :star: 3-5 전역 데이터

<br>

전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제입니다. 그래서 마치 '유령 같은 원격작용'처럼, 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵습니다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤(singleton)에서도 같은 문제가 발생합니다.

<br>

이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 [`변수 캡슐화하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_06_변수_캡슐화하기.md)입니다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용합니다. 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 됩니다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋습니다.

<br>

전역 데이터가 가변(mutable)이라면 특히나 다루기 까다롭습니다. 프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편입니다. 물론 언어에서 이런 기능을 제공해야 합니다.

<br>

전역 데이터가 조금 뿐이라면 감당할 수 있겠지만, 많아지면 걷잡을 수 없게 됩니다. 전역 데이터가 아주 조금만 있더라도 캡슐화하는 것이 좋습니다. 그래야 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있습니다.

<br>

<br>

## 다음 챕터

- [3.6 - 가변 데이터](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_06_가변_데이터.md)

<br>

## 이전 챕터

- [3.4 - 긴 매개변수 목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_04_긴_매개변수_목록.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/03_코드에서_나는_악취/03_00_코드에서_나는_악취.md)
