# :star: 2-5 리팩터링 시 고려할 문제

<br>

리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 합니다.

<br>

### 새 기능 개발 속도 저하

<br>

<br>

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

<br>

<br>

그렇더라도 상황에 맞게 조율해야 합니다. 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 합니다. 한번 본 문제일 때도 리팩터링부터 하는 편입니다.(물론 비슷한 패턴의 지저분한 코드를 여러 차례 마주친 뒤에야 리팩터링하여 제거하기로 결정할 때도 있습니다.)

<br>

반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편입니다. 때로는 어떻게 개선해야 할지 확실히 떠오르지 않아서 리팩터링을 미루기도 합니다. 물론 개선점이 떠오르면 시험 삼아 고쳐보고 더 나아지는지 살펴봅니다.

<br>

코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있습니다. 개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 합니다. 리팩터링 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해 서서히 형성됩니다. 리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 합니다.

<br>

사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 `클린 코드`나 `바람직한 엔지니어링 습관`처럼 도덕적인 이유로 정당화하는 것입니다. 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않습니다. 오로지 경제적인 이유로 하는 것입니다. 리팩터링은 개발 기간을 단축하고자 하는 것입니다. 리팩터링하도록 이끄는 동력은어디까지나 경제적인 효과에 있습니다.

<br>

### 코드 소유권

<br>

리팩터링하다 보면 모듈의 내부분 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많습니다. 함수의 이름을 바꾸고 싶고 그 함수를 호출하는 곳을 모두 찾을 수 있다면, 간단히 [`함수 선언 바꾸기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_05_함수_선언_바꾸기.md)로 선언 자체와 호출하는 곳 모두를 한 번에 바꿀 수 있지만, 함수를 호출하는 코드와 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있습니다. 또는 바꾸려는 함수가 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지는 고사하고, 실제로 쓰이거나 하는지조차 모를 수 있습니다.

<br>

이런 함수는 인터페이스를 누가 선언했는지에 관계없이 클라이언트가 사용하는 `공개된 인터페이스`에 속합니다. 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 됩니다.

<br>

코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대하는 입장입니다. 어떤 조직은 모든 코드의 소유권을 한 사람에게 맡기고 그 사람만 코드를 수정할 수 있게 하기도 합니다. 선호하는 방식은 코드의 소유권을 팀에 두는 것입니다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 합니다. 프로그래머마다 각자가 책임지는 영역이 있을 수는 있습니다. 이 말은 자신이 맡은 영역의 변경 사항을 관리하라는 뜻이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아닙니다.

<br>

이렇게 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있습니다. 예컨대 어떤 팀은 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는, 흡사 오픈소스 개발 모델을 권장하기도 합니다. 이렇게 하면 함수의 클라이언트도 바꿀 수 있습니다. 즉, 변경 사항 커밋을 클라이언트를 관리하는 쪽에서 승인하면 기존 함수를 삭제할 수 있습니다. 이 방식은 대규모 시스템 개발 시 잘 어울립니다.

<br>

### 브랜치

<br>

현재 흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터(트렁크) 브랜치에 통합해서 다른 팀원과 공유하는 것입니다. 그런데 이렇게 하면 어떤 기능 전체를 한 브랜치에만 구현해놓고, 프로덕션 버전으로 릴리스할 때가 돼서야 마스터에 통합하는 경우가 많습니다.

<br>

이런 기능 브랜치 방식에는 단점이 있습니다. 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워집니다. 이 고통을 줄이고자 많은 이들이 마스터를 개인 브랜치로 수시로 `리베이스`하거나 `머지`합니다. 하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없습니다.

<br>

`머지`와 `통합`을 명확히 구분합시다. 마스터를 브랜치로 `머지`하는 작업은 단방향입니다. 브랜치만 바뀌고 마스터는 그대로입니다. 반면 `통합`은 마스터를 개인 브랜치로 가져와서(풀해서) 작업한 결과를 다시 마스터에 올리는 (푸시하는) 양방향 처리를 뜻합니다. 그래서 마스터와 브랜치가 모두 변경됩니다.

<br>

누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없습니다. 그 때문에 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 시간이 길어질수록 기하급수적으로 늘어납니다. 4주간 작업한 브랜치들을 통합하는 노력은 2주간 작업한 브랜치들을 통합할 때보다 두 배 이상 듭니다. 이 때문에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 사람이 많습니다.

<br>

한편, 더 짧아야 한다고 주장하는 사람들의 방식을 지속적 통합(Continuous Integration, CI), 또는 트렁크 기반 개발(Trunk-Based Development, TBD)이라 합니다. CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합합니다. 이렇게 하면 머지의 복잡도를 상당히 낮출 수 있습니다. 하지만 CI를 적용하기 위해서는 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(feature toggle(기능플래그, feature flag))을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 합니다.

<br>

머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋기 때문입니다. 리팩터링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있습니다. 프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우가 이러한 예입니다. 이렇게 되면 머지 과정에서 의미 충돌이 생기기 쉽습니다. 특히 기능별 브랜치 방식에서는 리팩터링을 도저히 진행할 수 없을 정도로 심각한 머지 문제가 발생하기 쉽습니다.

<br>

기능별 브랜치를 사용하면 절대 안 된다는 말은 아닙니다. 브랜치를 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있습니다. 실제로 CI를 적용하는 이들도 기능별 브랜치를 사용합니다.(단, 마스터와 통합하는 작업을 매일 합니다.) CI를 완벽히 적용하지는 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 합니다.

<br>

### 테스팅

<br>

리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것입니다. 실수하더라도 재빨리 해결하면 문제가 되지 않습니다. 리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드의 범위가 높지 않습니다.

<br>

여기서 핵심은 오류를 재빨리 잡는 데 있습니다. 실제로 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요합니다. 그리고 이를 빠르게 실행할 수 있어야 수시로 테스트하는 데 부담이 없습니다. 달리 말하면 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 한다는 뜻입니다.

<br>

물론 테스트에 어느 정도 노력을 기울여야 하는 것은 사실이지만, 효과는 상당합니다. 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와줍니다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문입니다. 이 때 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있습니다.

<br>

또한 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있습니다. 자가 테스트 코드 없이 리팩터링할 때는 당연히 이 점을 염려해야 합니다. 견고한 테스트를 마련해야 한다고 그토록 강조하는 이유도 여기 있습니다.

<br>

테스트 문제는 다른 방식으로도 해결할 수 있습니다. 뛰어난 자동 리팩터링 기능을 제공하는 환경이라면 굳이 테스트하지 않아도 오류가 생기지 않는다고 확신할 수 있습니다. 따라서 안전한 자동 리팩터링만을 활용한다면 테스트 없이 리팩터링해도 좋습니다. 그러면 활용할 수 있는 리팩터링 기법 수가 제한되지만, 자동 리팩터링들만으로도 의미 있는 효과를 보기에 충분합니다.

<br>

이러한 생각 때문에 안전하다고 검증된 몇 가지 리팩터링 기법만 조합해서 사용하자는 흐름이 등장했습니다. 이 방식을 적용해본 팀은 테스트 커버리지가 넓지 않은 대규모 코드베이스도 효과적으로 리팩터링할 수 있음을 확인했습니다. 최근에 등장한 움직임이라 이 책에서는 자세히 다루지 않겠지만 간단히 맛보고 싶은 독자는 제이 바주지(Jay Bazuzi)의 글을 읽어보기 바랍니다.

<br>

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관됩니다. CI에 통합된 테스트는 XP의 권장사항이자 지속적배포(Continuous Delivery, CD)의 핵심이기도 합니다.

<br>

### 레거시 코드

<br>

물려받은 레거시 코드(legacy code)는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많습니다. 무엇보다도 다른 사람이 작성한 것입니다(생각만 해도 끔찍합니다).

<br>

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움됩니다. 하지만 대규모 레거시 시스템을 테스트 코드 없이 리팩터링하기는 어렵습니다. 이 문제의 정답은 당연히 테스트 보강입니다. 단순 노동에 가까울 수 있다는 점을 제외하면 간단히 할 수 있어 보이지만, 막상 해보면 생각보다 훨씬 까다롭습니다. 보통은 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있습니다. 물론 그런 시스템이라면 테스트를 갖추고 있을 것이라서 애초에 이런 걱정을 할 일이 없습니다.

<br>

쉽게 해결할 방법은 없습니다. 그나마 해줄 수 있는 조언은 `레거시 코드 활용 전략(에이콘, 2018)`에 나온 지침을 충실히 따르는 것입니다. 십 년 이상 지난 지금도 그대로 적용할 수 있는 지침들입니다. 주요 내용을 한 마디로 표현하면 `프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다`는 것입니다.

<br>

이러한 틈새를 만들 때 리팩터링이 활용됩니다. 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 할 위험입니다. 이럴 때 안전한 자동 리팩터링 도구가 있다면 큰 도움이 됩니다. 그래서 사실 상당히 어려운 작업입니다. 처음부터 자가 테스트 코드를 작성해야 한다고 그토록 강조한 이유가 이 때문입니다.

<br>

테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않습니다. 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이 좋습니다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력합니다. 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링합니다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 합니다.

<br>

### 데이터베이스

<br>

진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법은 현재 널리 적용되고 있습니다. 이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있습니다.

<br>

간단한 예로 필드(열)의 이름을 변경하는 경우를 생각해봅시다. [`함수 선언 바꾸기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_05_함수_선언_바꾸기.md)에 따르면 데이터 구조의 원래 선언과 이 데이터 구조를 호출하는 코드를 모두 찾아서 한 번에 변경해야 합니다. 그런데 예전 필드를 사용하는 데이터 모두가 새 필드를 사용하도록 변환해야 하는 부담도 따릅니다.

<br>

이럴 때는 이 변환을 수행하는 코드를 간단히 작성한 다음, 선언된 데이터구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장합니다. 그런 다음 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행합니다.

<br>

다른 리팩터링과 마찬가지로 이 기법도 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심입니다. 그래야 마이그레이션 후에도 정상 작동할 수 있습니다. 그리고 여러 단계를 순차적으로 연결해서 데이터베이스의 구조와 그 안에 담긴 데이터를 큰 폭으로 변경할 수도 있습니다.

<br>

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다릅니다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽습니다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽습니다. 이를테면 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않습니다. 그런 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정합니다.

<br>

그다음에는 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체합니다. 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제합니다. 이렇게 데이터베이스를 변경하는 방식은 병렬 수정(parallel change, 또는 팽창-수축(expand-contact))의 일반적인 예입니다.

<br>

<br>

## 다음 챕터

- [2.6 - 리팩터링, 아키텍처, 애그니(YAGNI)](<https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_06_리팩터링_아키텍처_애그니(YAGNI).md>)

<br>

## 이전 챕터

- [2.4 - 언제 리팩터링해야 할까?](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_04_언제_리팩터링해야_할까.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_00_리팩터링_원칙.md)
