# :star: 2-5 리팩터링 시 고려할 문제

<br>

리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 합니다.

<br>

### 새 기능 개발 속도 저하

<br>

<br>

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

<br>

<br>

그렇더라도 상황에 맞게 조율해야 합니다. 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 합니다. 한번 본 문제일 때도 리팩터링부터 하는 편입니다.(물론 비슷한 패턴의 지저분한 코드를 여러 차례 마주친 뒤에야 리팩터링하여 제거하기로 결정할 때도 있습니다.)

<br>

반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편입니다. 때로는 어떻게 개선해야 할지 확실히 떠오르지 않아서 리팩터링을 미루기도 합니다. 물론 개선점이 떠오르면 시험 삼아 고쳐보고 더 나아지는지 살펴봅니다.

<br>

코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있습니다. 개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 합니다. 리팩터링 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해 서서히 형성됩니다. 리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 합니다.

<br>

사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 `클린 코드`나 `바람직한 엔지니어링 습관`처럼 도덕적인 이유로 정당화하는 것입니다. 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않습니다. 오로지 경제적인 이유로 하는 것입니다. 리팩터링은 개발 기간을 단축하고자 하는 것입니다. 리팩터링하도록 이끄는 동력은어디까지나 경제적인 효과에 있습니다.

<br>

### 코드 소유권

<br>

리팩터링하다 보면 모듈의 내부분 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많습니다. 함수의 이름을 바꾸고 싶고 그 함수를 호출하는 곳을 모두 찾을 수 있다면, `간단히 함수 선언 바꾸기`로 선언 자체와 호출하는 곳 모두를 한 번에 바꿀 수 있지만, 함수를 호출하는 코드와 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있습니다. 또는 바꾸려는 함수가 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지는 고사하고, 실제로 쓰이거나 하는지조차 모를 수 있습니다.

<br>

이런 함수는 인터페이스를 누가 선언했는지에 관계없이 클라이언트가 사용하는 `공개된 인터페이스`에 속합니다. 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 됩니다.

<br>

코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대하는 입장입니다. 어떤 조직은 모든 코드의 소유권을 한 사람에게 맡기고 그 사람만 코드를 수정할 수 있게 하기도 합니다. 선호하는 방식은 코드의 소유권을 팀에 두는 것ㅇ비니다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 합니다. 프로그래머마다 각자가 책임지는 영역이 있을 수는 있습니다. 이 말은 자신이 맡은 영역의 변경 사항을 관리하라는 뜻이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아닙니다.

<br>

이렇게 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있습니다. 예컨대 어떤 팀은 다른 팀 사람이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는, 흡사 오픈소스 개발 모델을 권장하기도 합니다. 이렇게 하면 함수의 클라이언트도 바꿀 수 있습니다. 즉, 변경 사항 커밋을 클라이언트를 관리하는 쪽에서 승인하면 기존 함수를 삭제할 수 있습니다. 이 방식은 대규모 시스템 개발 시 잘 어울립니다.

<br>

### 브랜치

<br>

<br>

## 다음 챕터

- [2.6 - 리팩터링, 아키텍처, 애그니(YAGNI)](<https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_06_리팩터링_아키텍처_애그니(YAGNI).md>)

<br>

## 이전 챕터

- [2.4 - 언제 리팩터링해야 할까?](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_04_언제_리팩터링해야_할까.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_00_리팩터링_원칙.md)
