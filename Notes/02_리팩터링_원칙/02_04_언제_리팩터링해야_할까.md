# :star: 2-4 언제 리팩터링해야 할까?

<br>

프로그래밍할 때 거의 한 시간 간격으로 리팩터링합니다. 그러다 보니 작업 흐름에 리팩터링을 녹이는 방법이 여러 가지임을 알게 됐습니다.

<br>

> ### 3의 법칙
>
> 이건 돈 로버츠가 제시한 가이드입니다. <br>
>
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다. <br>
>    야구를 좋아하는 사람은 '스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)'로 기억하자.

<br>

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

<br>

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전입니다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾습니다. 가령 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 수 있습니다. 함수를 복제해서 해당 값만 수정해도 되지만, 그러면 중복 코드가 생깁니다.

<br>

나중에 이 부분을 변경할 일이 생기면 원래 코드와 복제한 코드를 모두 수정해야 하며, 더 심한 경우는 복제한 코드가 어디 있는지까지 일일이 찾아내야 합니다. 이럴 때는 리팩터링 모자를 쓰고 `함수 매개변수화하기`를 적용합니다. 그러고 나면 그 함수에 필요한 매개변수를 지정해서 호출하기만 하면 됩니다.

<br>

> 비유하면 지금 위치에서 동쪽으로 100km를 이동하려는데 그 사이를 숲이 가로막고 있다면, 좀 둘러가더라도 20km 북쪽에 있는 고속도로를 타는 편이 세 배나 빠를 수 있다. 다들 "직진!"을 외치더라도, 때로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다. - 제시카 커

<br>

버그를 잡을 때도 마찬가지입니다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편합니다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있습니다. 이 처럼 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있습니다.

<br>

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

<br>

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 합니다. 그 코드를 작성한 사람은 자신일 수도 있고 다른 사람일 수도 있습니다. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아봅니다. 조건부 로직의 구조가 이상하지 않은지, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴봅니다.

<br>

리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있습니다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있습니다. 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있습니다.

<br>

이렇게 하면 나중은 물론 지금 당장 효과를 볼 때도 많습니다. 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 합니다. 그러면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작합니다. 이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를 결코 발견할 수 없습니다.

<br>

### 쓰레기 줍기 리팩터링

<br>

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있습니다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있습니다. 이때 약간 절충을 해야 합니다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것입니다. 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리합시다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링입니다.

<br>

물론 당장은 더 급한 일이 있을 수 있지만 조금이나마 개선해두는 것이 좋습니다. 캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리하고 떠납시다. 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것입니다. 리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실입니다. 그래서 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 합니다.

<br>

### 계획된 리팩터링과 수시로 하는 리팩터링

<br>

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아닙니다. 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리합니다.

<br>

<br>

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

<br>

<br>

잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 합니다. 예컨대 매개변수화하거나 개별 함수로 나누는 기준을 정합니다. 어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있습니다. 이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링하기가 더 쉽습니다.

<br>

<br>

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단 만만치 않을 수 있다) 그런 다음 쉽게 수정하자

<br>

<br>

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 `수정`하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 압니다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정됩니다. 이 때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많습니다. 그렇다고 해 계획된 리팩터링이 무조건 나쁘다는 말은 아닙니다. 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있습니다.

<br>

하지만 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 합니다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야합니다. 버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있지만, 이 견해에 완전히 동의하지는 않습니다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있습니다. 리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 팀에 적합한 방식을 실험을 통해 찾아내야 합니다.

<br>

### 오래 걸리는 리팩터링

<br>

리팩터링은 대부분 몇 분 안에 끝납니다. 길어야 몇 시간 정도입니다. 하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있습니다. 팀 전체가 리팩터링에 매달리는 데는 회의적입니다. 그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많습니다. 누구든지 리팩터링해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식입니다. 리팩터링이 코드를 꺠트리지 않는다는 장점을 활용하는 것입니다.

<br>

예컨대 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련합니다. 기존 코드가 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있습니다.(이 전략을 `추상화로 갈아타기`라고 합니다.)

<br>

### 코드 리뷰에 리팩터링 활용하기

<br>

리팩터링은 다른 이의 코드를 리뷰하는 데도 도움됩니다. 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴봅니다. 쉽다면 실제로 리팩터링합니다. 이 과정을 몇 번 반복하면 내가 떠올린 아이디어를 실제로 적용했을 떄의 모습을 더 명확하게 볼 수 있습니다. 눈으로 직접 확인하는 것입니다. 그러다 보면 리팩터링해보지 않고는 절대 떠올릴 수 없던 한 차원 높은 아이디어가 떠오르기도 합니다.

<br>

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움됩니다. 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 떄문입니다.

<br>

코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다릅니다. 흔히 쓰는 풀요청 모델(pull request model, 코드 작성자 없이 검토하는 방식)에서는 그리 효과적이지 않습니다. 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋습니다. 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것입니다. 이렇게 하면 자연스럽게 프로그래밍 과정 안에 지속적인 코드 리뷰가 녹아 있는 페어 프로그래밍이 됩니다.

<br>

### 관리자에게는 뭐라고 말해야 할까?

<br>

관리자와 고객이 '리팩터링은 누적된 오류를 잡는 일이거나, 혹은 가치 있는 기능을 만들어내지 못하는 작업'이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있었습니다. 리팩터링만을 위한 일정을 몇 주씩 잡는 개발팀을 보면 오해는 더욱 커집니다.

<br>

관리자가 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면 리팩터링의 필요성을 쉽게 설득할 수 있습니다. 이런 관리자는 오히려 정기적인 리팩터링을 권장할 뿐만 아니라 팀이 리팩터링을 충분히 하고 있는지 살펴보기도 합니다.

<br>

물론 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모릅니다. 이런 상황에 있는 이들에게는 '리팩터링한다고 말하지 말라'고 조언하겠습니다.

<br>

일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원합니다. 그리고 구체적인 방법은 개발자가 판단해야 합니다. 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링입니다. 그래서 리팩터링부터 합니다.

<br>

### 리팩터링하지 말아야 할 때

<br>

리팩터링하면 안되는상황도 있습니다. 지저분한 코드를 발견해도 굳이 필요가 없다면 리팩터링하지 않습니다. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둡니다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있습니다.

<br>

리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않습니다. 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많기 떄문에, 리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 합니다.

<br>

<br>

## 다음 챕터

- [2.5 - 리팩터링 시 고려할 문제](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_05_리팩터링_시_고려할_문제.md)

<br>

## 이전 챕터

- [2.3 - 리팩터링하는 이유](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_03_리팩터링하는_이유.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_00_리팩터링_원칙.md)
