# :star: 2-8 리팩터링과 성능

<br>

리팩터링하면 프로그램 성능이 느려질까봐 걱정하는 사람이 많습니다. '직관적인 설계 vs 성능'은 중요한 주제입니다. 예전에도 너무 느린 소프트웨어는 고객이 수용해주지 않았고 빠른 하드웨어가 등장하더라도 성능 기준이 낮아지는 경우는 드물었습니다. 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실입니다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워집니다. 하드 리얼타임(hard real-time)시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것입니다.

<br>

빠른 소프트웨어를 작성한 방법 세 가지가 있는데, 그중 가장 엄격한 방법은 시간 예산 분배(time budgeting)방식으로, 하드 리얼타임 시스템에서 많이 사용합니다. 이 방식에 따르면 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당합니다. 컴포넌트는 할당된 자원 예산을 초과할 수 없습니다.

<br>

단, 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있습니다. 시간 예산 분배 방식은 특히 엄격한 시간 엄수를 강조합니다. 심장 박동 조율기처럼 데이터가 늦게 도착하면 안 되는 시스템에서는 이러한 점이 굉장히 중요합니다. 반면, 사내 정보 시스템과 같은 부류에는 맞지 않는 기법입니다.

<br>

두 번째 방법은 끊임없이 관심을 기울이는 것입니다.

<br>

<br>

## 다음 챕터

- [2.9 - 리팩터링의 유래](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_09_리팩터링의_유래.md)

<br>

## 이전 챕터

- [2.7 - 리팩터링과 소프트웨어 개발 프로세스](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_07_리팩터링과_소프트웨어_개발_프로세스.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_00_리팩터링_원칙.md)
