# :star: 2-6 리팩터링 아키텍처 애그니(YAGNI)

<br>

앞에서 말했듯이 레거시 코드는 변경하기 어려울 떄가 많습니다. 특히 탄탄한 테스트가 뒷받침해주지 못하면 더더욱 어렵습니다. 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있습니다. 코딩 전에 아키텍처를 확정지으려 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것입니다.

<br>

하지만 막상 해보면 실현할 수 없는 목표일 때가 많습니다. 우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다합니다.

<br>

한 가지 방법은 향후 변경에 대처할 수 있는 유연성 메커니즘(flexibility mechanism)을 소프트웨어에 심어두는 것입니다. 가령 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있습니다. 그래서 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가합니다. 이런 매개변수가 바로 유연성 메커니즘입니다. 물론 메커니즘들이 그렇듯 치러야 할 비용이 있습니다.

<br>

매개변수를 생각나는 대로 추가하다 보면 당장의 쓰임에 비해 함수가 너무 복잡해집니다. 또한 깜박 잊은 매개변수가 있다면 앞서 추가해둔 매개변수들 때문에 새로 추가하기가 더 어려워집니다. 간혹 유연성 메커니즘을 잘못 구현할 때도 있습니다. 요구사항이 당초 예상과 다르게 바뀌기 때문일 수도 있고, 내가 설계한 메커니즘 자체에 결함이 있어서일 때도 있습니다. 이 모든 상황을 고려하다 보면 유연성 메커니즘이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분입니다.

<br>

리팩터링을 활용하면 다르게 접근할 수 있습니다. 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꿉니다. 그 과정에서 (작고 멋진 이름의 함수처럼) 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가합니다.

<br>

호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않습니다. 그러다 매개변수를 추가해야 할 시점이 오면 간단한 리팩터링 기법인 `함수 매개변수화하기`로 해결합니다. 예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움될 때가 많습니다. 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가합니다.

<br>

이런 식으로 설계하는 방식을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(에그니, "you aren't going to need it"(필요 없을 거다)의 줄임말) 등으로 부릅니다. YAGNI를 문자 그대로 해석해서 적용할 때도 있지만, 아키텍처를 전혀 고려하지 말라는 뜻은 아닙니다. YAGNI는 아키텍처와 설계를 개발 프로세스에 녹이는 또 다른 방식이며, 리팩터링의 뒷받침 없이는 효과를 볼 수 없습니다.

<br>

YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아닙니다. 리팩터링으로는 변경하기 어려워서 미리 생각해두면 시간이 절약되는 경우도 얼마든지 있습니다. 다만 이제는 둘 사이의 균형점이 크게 달라졌습니다. 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫습니다. 이러한 경향은 진화형 아키텍처(evolutionary archicture) 원칙이 발전하는 계기가 됐습니다(진화형 아키텍처는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구합니다.).

<br>

<br>

## 다음 챕터

- [2.7 - 리팩터링과 소프트웨어 개발 프로세스](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_07_리팩터링과_소프트웨어_개발_프로세스.md)

<br>

## 이전 챕터

- [2.5 - 리팩터링 시 고려할 문제](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_05_리팩터링_시_고려할_문제.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_00_리팩터링_원칙.md)
