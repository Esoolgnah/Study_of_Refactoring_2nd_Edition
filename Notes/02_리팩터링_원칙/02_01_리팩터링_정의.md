# :star: 2-1 리팩터링 정의

<br>

`리팩터링`이라는 용어는 명사로도 쓸 수 있고, 동사로도 쓸 수 있습니다. 먼저 명사로 쓸 때는 다음과 같이 정의합니다.

<br>

> 리팩터링: [명사] 소프트웨어의 겉보지 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

<br>

앞 장에서 본 [`함수 추출하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_01_함수_추출하기.md) 와 `조건부 로직을 다형성으로 바꾸기`처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당합니다. 동사 버전의 리팩터링 정의는 다음과 같습니다.

<br>

> 리팩터링(하다): [동사] 소프트웨어 겉보기 동작은 그대로 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

<br>

예를 들어 두 버전의 용어를 한 문장에 담으면, '앞으로 몇 시간은 `리팩터링`할 것 같은데 그 사람이 적용하는 `리팩터링`은 수십 가지나 될 것 같다처럼 표현할 수 있습니다.'

<br>

앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 `리팩터링`입니다. 또한 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있습니다.

<br>

> 누군가 "`리팩터링`하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 `리팩터링`한 것이 아니다.

<br>

코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 `재구성`이라는 포괄적인 용어로 표현하고, `리팩터링`은 `재구성` 중 특수한 한 형태로 봅니다. 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 `리팩터링`하는 것이 오히려 비효율적이라고 생각하기 쉽습니다.

<br>

하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있습니다. 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문입니다.

<br>

앞에서 `리팩터링`을 정의할 때 겉보기 동작이란 표현을 썼습니다. `리팩터링`하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻입니다. 그렇다고 완전히 똑같다는 말은 아닙니다. 가령 [`함수 추출하기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_01_함수_추출하기.md)를 거치면 콜스택이 달라져서 성능이 변할 수 있습니다. 그렇다 해도 사용자 관점에서는 달라지는 점이 없어야 합니다.

<br>

특히 [`함수 선언 바꾸기`](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/06_기본적인_리팩터링/06_05_함수_선언_바꾸기.md)기나 `함수 옮기기` 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많습니다. 한편, `리팩터링` 과정에서 발견된 버그는 `리팩터링` 후에도 그대로 남아 있어야 합니다.(단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮습니다.)

<br>

`리팩터링`은 `성능 최적화`와 비슷합니다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지합니다. `리팩터링`의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것입니다. 프로그램 성능은 좋아질 수도, 나빠질 수도 있습니다. 반면 `성능 최적화`는 오로지 속도 개선에만 신경 씁니다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 합니다.

<br>

<br>

## 다음 챕터

- [2.2 - 두 개의 모자](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_02_두_개의_모자.md)

<br>

## 목록으로

- [목록](https://github.com/Esoolgnah/Summary_of_Refactoring_2nd_Edition/blob/main/Notes/02_리팩터링_원칙/02_00_리팩터링_원칙.md)
